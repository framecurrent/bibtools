#! /usr/bin/env python
# -*- mode: python; coding: utf-8 -*-
# Copyright 2014 Peter Williams <peter@newton.cx>
# Licensed under the GNU General Public License, version 3 or higher.

"""
Docstring!
"""

import errno, os.path, re, sqlite3, sys


# Generic app infrastructure

def die (fmt, *args):
    if not len (args):
        raise SystemExit ('error: ' + str (fmt))
    raise SystemExit ('error: ' + fmt % args)


class BibError (Exception):
    def __init__ (self, fmt, *args):
        if not len (args):
            self.bibmsg = str (fmt)
        else:
            self.bibmsg = fmt % args

    def __str__ (self):
        return self.bibmsg


class UsageError (BibError):
    pass

class PubLocateError (BibError):
    pass


# The app!

def _make_data_pather ():
    # XXXX
    def pathfunc (*args):
        return os.path.join ('/a/share/bib', *args)
    return pathfunc


datapath = _make_data_pather ()


def _make_user_data_pather ():
    datadir = os.environ.get ('XDG_DATA_HOME',
                              os.path.expanduser ('~/.local/share'))

    def pathfunc (*args):
        return os.path.join (datadir, 'bib', *args)

    return pathfunc


bibpath = _make_user_data_pather ()
dbpath = bibpath ('db.sqlite3')


def connect ():
    return sqlite3.connect (dbpath)


_arxiv_re_1 = re.compile (r'^\d\d[01]\d\.\d+')
_arxiv_re_2 = re.compile (r'^[a-z-]+/\d+')
_bibcode_re = re.compile (r'^\d\d\d\d[a-zA-Z0-9&]+')
_doi_re = re.compile (r'^10\.\d+/.*')

def locate_pubs (db, text, noneok=False, manyok=False):
    """Given some text that we believe identifies a publication, try to
    retrieve its ID number. A key routine."""

    if text.startswith ('doi:'):
        q = db.execute ('SELECT id FROM pubs WHERE doi = ?', (text[4:], ))
        matchtext = 'DOI = ' + text[4:]
    elif _doi_re.match (text) is not None:
        q = db.execute ('SELECT id FROM pubs WHERE doi = ?', (text, ))
        matchtext = 'DOI = ' + text
    elif _bibcode_re.match (text) is not None:
        q = db.execute ('SELECT id FROM pubs WHERE bibcode = ?', (text, ))
        matchtext = 'bibcode = ' + text
    elif _arxiv_re_1.match (text) is not None or arxiv_re_2.match (text) is not None:
        q = db.execute ('SELECT id FROM pubs WHERE arxiv = ?', (text, ))
        matchtext = 'arxiv = ' + text
    else:
        # note: we do this even if noneok=True.
        raise PubLocateError ('couldn\'t understand publication identifier "%s"', text)

    ids = list (t[0] for t in q)

    if not noneok and not len (ids):
        raise PubLocateError ('no publications matched ' + matchtext)
    if not manyok and len (ids) > 1:
        raise PubLocateError ('more than one publication matched ' + matchtext)

    return ids


def locate_pub (db, text, noneok=False):
    ids = locate_pubs (db, text, noneok=noneok, manyok=False)

    if not len (ids):
        return None
    return ids[0]


# Commands

def cmd_init (argv):
    try:
        os.makedirs (bibpath ())
    except OSError as e:
        if e.errno != errno.EEXIST or not os.path.isdir (bibpath ()):
            raise

    if os.path.exists (dbpath):
        die ('the file "%s" already exists', dbpath)

    with connect () as db:
        try:
            init = open (datapath ('schema.sql')).read ()
            db.executescript (init)
        except sqlite3.OperationalError as e:
            die ('cannot initialize "%s": %s', dbpath, e)


def cmd_info (argv):
    if len (argv) != 2:
        raise UsageError ('expected exactly 1 argument')

    idtext = argv[1]

    with connect () as db:
        # TODO: should be OK to match multiple publications and print them all
        # out.

        try:
            id = locate_pub (db, idtext)
        except PubLocateError as e:
            die (e)

        for row in db.execute ('SELECT * FROM pubs WHERE id = ?', (id, )):
            _, abstract, arxiv, bibcode, doi, firstsurname, title, year = row

            if firstsurname is None:
                firstsurname = '(no author)'
            if year is None:
                year = 'no year'
            if title is None:
                title = '(no title)'

            print '%s*(%s): %s' % (firstsurname, year, title)

            if arxiv is not None:
                print 'arxiv:', arxiv
            if bibcode is not None:
                print 'bibcode:', bibcode
            if doi is not None:
                print 'DOI:', doi

            if abstract is not None:
                print
                # XXX linewrapping etc
                print abstract


def _ingest_one (db, rec):
    abstract = rec.get ('abstract')
    arxiv = rec.get ('eprint')
    bibcode = None # XXX
    doi = rec.get ('doi')
    title = rec.get ('title')
    year = rec.get ('year')

    if year is not None:
        year = int (year)

    if 'author' in rec:
        t = rec['author'][0].replace ('{', '').replace ('}', '').replace ('~', ' ')
        firstsurname = t.split (',', 1)[0]
    else:
        firstsurname = None

    db.execute ('INSERT INTO pubs VALUES (NULL, ?, ?, ?, ?, ?, ?, ?)',
                (abstract, arxiv, bibcode, doi, firstsurname, title, year))


def cmd_ingest (argv):
    if len (argv) != 2:
        raise UsageError ('expected exactly 1 argument')

    bibpath = argv[1]
    from bibtexparser.bparser import BibTexParser
    from bibtexparser.customization import author, type, convert_to_unicode

    custom = lambda r: author (type (convert_to_unicode (r)))

    with open (bibpath) as bibfile, connect () as db:
        bp = BibTexParser (bibfile, customization=custom)

        for rec in bp.get_entry_list ():
            _ingest_one (db, rec)


def cmd_jpage (argv):
    if len (argv) != 2:
        raise UsageError ('expected exactly 1 argument')

    import webbrowser
    from urllib2 import quote

    idtext = argv[1]

    with connect () as db:
        try:
            id = locate_pub (db, idtext)
        except PubLocateError as e:
            die (e)

        doi = list (db.execute ('SELECT doi FROM pubs WHERE id = ?', (id, )))[0][0]
        if doi is None:
            die ('cannot open journal website: no DOI for record')

        url = 'http://dx.doi.org/' + quote (doi)
        webbrowser.open (url)


# Toplevel driver infrastructure

def usage ():
    print 'usage goes here'


def driver (argv):
    if len (argv) == 1 or argv[1] == '--help':
        usage ()
        return

    cmdname = argv[1]
    cmdfunc = globals ().get ('cmd_' + cmdname.replace ('-', '_'))

    if not callable (cmdfunc):
        die ('"%s" is not a recognized subcommand; run me without '
             'arguments for usage help', cmdname)

    try:
        cmdfunc (argv[1:])
    except UsageError as ue:
        # TODO: synopsize command-specific usage help as an attribute on the
        # function (so we can auto-gen a multi-command usage summary too)
        raise SystemExit ('usage error: ' + ue.uimsg)

if __name__ == '__main__':
    driver (sys.argv)
